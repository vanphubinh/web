/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { AreAllOptional, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional } from "@openapi-qraft/tanstack-query-react-types";
import type { DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
import type { CancelOptions, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, Updater } from "@tanstack/query-core";
export interface MeasurementService {
    /**
     * @summary Create a new UOM
     * @description Create a new UOM with the given name
     */
    createUom: {
        /**
         * @summary Create a new UOM
         * @description Create a new UOM with the given name
         */
        getMutationKey(parameters: CreateUomParameters | void): ServiceOperationMutationKey<CreateUomSchema, CreateUomParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.createUom.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.createUom.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends CreateUomBody, TContext = unknown>(parameters: CreateUomParameters, options?: ServiceOperationUseMutationOptions<CreateUomSchema, CreateUomData, CreateUomParameters, TVariables, CreateUomError | Error, TContext>): UseMutationResult<CreateUomData, CreateUomError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.createUom.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.createUom.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<CreateUomBody, CreateUomParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<CreateUomSchema, CreateUomData, CreateUomParameters, TVariables, CreateUomError | Error, TContext>): UseMutationResult<CreateUomData, CreateUomError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Create a new UOM
         * @description Create a new UOM with the given name
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const createUomTotal = qraft.measurementService.createUom.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const createUomTotal = qraft.measurementService.createUom.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<CreateUomBody, CreateUomData, CreateUomParameters, CreateUomError | Error, TContext> | MutationFiltersByMutationKey<CreateUomSchema, CreateUomBody, CreateUomData, CreateUomParameters, CreateUomError | Error, TContext>): number;
        /**
         * @summary Create a new UOM
         * @description Create a new UOM with the given name
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<CreateUomBody, CreateUomData, CreateUomParameters, CreateUomError | Error, TContext> | MutationFiltersByMutationKey<CreateUomSchema, CreateUomBody, CreateUomData, CreateUomParameters, CreateUomError | Error, TContext>): number;
        /**
         * @summary Create a new UOM
         * @description Create a new UOM with the given name
         */
        (options: ServiceOperationMutationFnOptions<CreateUomBody, CreateUomParameters>, client?: (schema: CreateUomSchema, options: ServiceOperationMutationFnOptions<CreateUomBody, CreateUomParameters>) => Promise<RequestFnResponse<CreateUomData, CreateUomError>>): Promise<RequestFnResponse<CreateUomData, CreateUomError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Create a new UOM
         * @description Create a new UOM with the given name
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const createUomPendingMutationVariables = qraft.measurementService.createUom.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const createUomMutationData = qraft.measurementService.createUom.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<CreateUomData, CreateUomError | Error, MutationVariables<CreateUomBody, CreateUomParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<CreateUomBody, CreateUomData, CreateUomParameters, CreateUomError | Error, TContext> | MutationFiltersByMutationKey<CreateUomSchema, CreateUomBody, CreateUomData, CreateUomParameters, CreateUomError | Error, TContext>;
            select?: (mutation: Mutation<CreateUomData, CreateUomError | Error, MutationVariables<CreateUomBody, CreateUomParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: CreateUomSchema;
        types: {
            parameters: CreateUomParameters;
            data: CreateUomData;
            error: CreateUomError;
            body: CreateUomBody;
        };
    };
    /** @summary Delete a UOM by ID */
    deleteUom: {
        /** @summary Delete a UOM by ID */
        getMutationKey(parameters: DeleteUomParameters | void): ServiceOperationMutationKey<DeleteUomSchema, DeleteUomParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.deleteUom.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.deleteUom.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteUomBody, TContext = unknown>(parameters: DeleteUomParameters, options?: ServiceOperationUseMutationOptions<DeleteUomSchema, DeleteUomData, DeleteUomParameters, TVariables, DeleteUomError | Error, TContext>): UseMutationResult<DeleteUomData, DeleteUomError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.deleteUom.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.measurementService.deleteUom.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteUomBody, DeleteUomParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteUomSchema, DeleteUomData, DeleteUomParameters, TVariables, DeleteUomError | Error, TContext>): UseMutationResult<DeleteUomData, DeleteUomError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Delete a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteUomTotal = qraft.measurementService.deleteUom.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteUomTotal = qraft.measurementService.deleteUom.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteUomBody, DeleteUomData, DeleteUomParameters, DeleteUomError | Error, TContext> | MutationFiltersByMutationKey<DeleteUomSchema, DeleteUomBody, DeleteUomData, DeleteUomParameters, DeleteUomError | Error, TContext>): number;
        /** @summary Delete a UOM by ID */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteUomBody, DeleteUomData, DeleteUomParameters, DeleteUomError | Error, TContext> | MutationFiltersByMutationKey<DeleteUomSchema, DeleteUomBody, DeleteUomData, DeleteUomParameters, DeleteUomError | Error, TContext>): number;
        /** @summary Delete a UOM by ID */
        (options: ServiceOperationMutationFnOptions<DeleteUomBody, DeleteUomParameters>, client?: (schema: DeleteUomSchema, options: ServiceOperationMutationFnOptions<DeleteUomBody, DeleteUomParameters>) => Promise<RequestFnResponse<DeleteUomData, DeleteUomError>>): Promise<RequestFnResponse<DeleteUomData, DeleteUomError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Delete a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteUomPendingMutationVariables = qraft.measurementService.deleteUom.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteUomMutationData = qraft.measurementService.deleteUom.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteUomData, DeleteUomError | Error, MutationVariables<DeleteUomBody, DeleteUomParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteUomBody, DeleteUomData, DeleteUomParameters, DeleteUomError | Error, TContext> | MutationFiltersByMutationKey<DeleteUomSchema, DeleteUomBody, DeleteUomData, DeleteUomParameters, DeleteUomError | Error, TContext>;
            select?: (mutation: Mutation<DeleteUomData, DeleteUomError | Error, MutationVariables<DeleteUomBody, DeleteUomParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteUomSchema;
        types: {
            parameters: DeleteUomParameters;
            data: DeleteUomData;
            error: DeleteUomError;
            body: DeleteUomBody;
        };
    };
    /** @summary Get a UOM by ID */
    getUomById: {
        /** @summary Get a UOM by ID */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>, options?: CancelOptions): Promise<void>;
        /** @summary Get a UOM by ID */
        getQueryKey(parameters: GetUomByIdParameters): ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.getUomById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUomByIdData>(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options?: Omit<UndefinedInitialDataOptions<GetUomByIdData, GetUomByIdError, TData, ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>>, "queryKey">): UseQueryResult<TData, GetUomByIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.getUomById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUomByIdData>(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options: Omit<DefinedInitialDataOptions<GetUomByIdData, GetUomByIdError, TData, ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetUomByIdError | Error>;
        /** @summary Get a UOM by ID */
        fetchInfiniteQuery<TPageParam extends GetUomByIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUomByIdSchema, GetUomByIdData, GetUomByIdParameters, TPageParam, GetUomByIdError>): Promise<OperationInfiniteData<GetUomByIdData, GetUomByIdParameters>>;
        /** @summary Get a UOM by ID */
        prefetchInfiniteQuery<TPageParam extends GetUomByIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUomByIdSchema, GetUomByIdData, GetUomByIdParameters, TPageParam, GetUomByIdError>): Promise<void>;
        /** @summary Get a UOM by ID */
        ensureInfiniteQueryData<TPageParam extends GetUomByIdParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetUomByIdSchema, GetUomByIdData, GetUomByIdParameters, TPageParam, GetUomByIdError>): Promise<OperationInfiniteData<GetUomByIdData, GetUomByIdParameters>>;
        /** @summary Get a UOM by ID */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetUomByIdSchema, GetUomByIdData, GetUomByIdParameters, GetUomByIdError>): Promise<GetUomByIdData>;
        /** @summary Get a UOM by ID */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetUomByIdSchema, GetUomByIdData, GetUomByIdParameters, GetUomByIdError>): Promise<void>;
        /** @summary Get a UOM by ID */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetUomByIdSchema, GetUomByIdData, GetUomByIdParameters, GetUomByIdError>): Promise<GetUomByIdData>;
        /** @summary Get a UOM by ID */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters)): OperationInfiniteData<GetUomByIdData, GetUomByIdParameters> | undefined;
        /** @summary Get a UOM by ID */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>,
            data: NoInfer<OperationInfiniteData<GetUomByIdData, GetUomByIdParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>,
            data: GetUomByIdData | undefined
        ]>;
        /** @summary Get a UOM by ID */
        getQueryData(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters)): GetUomByIdData | undefined;
        /** @summary Get a UOM by ID */
        getQueryState(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters)): QueryState<GetUomByIdData, GetUomByIdError> | undefined;
        /** @summary Get a UOM by ID */
        getInfiniteQueryState(parameters: GetUomByIdParameters | ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>): QueryState<OperationInfiniteData<GetUomByIdData, GetUomByIdParameters>, GetUomByIdError> | undefined;
        /** @summary Get a UOM by ID */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get a UOM by ID */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>): number;
        /** @summary Get a UOM by ID */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetUomByIdSchema, GetUomByIdParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetUomByIdParameters, TMeta, TSignal>), client?: (schema: GetUomByIdSchema, options: {
            parameters: GetUomByIdParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetUomByIdData, GetUomByIdError>>): Promise<RequestFnResponse<GetUomByIdData, GetUomByIdError>>;
        /** @summary Get a UOM by ID */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get a UOM by ID */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>): void;
        /** @summary Get a UOM by ID */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>, options?: ResetOptions): Promise<void>;
        /** @summary Get a UOM by ID */
        setInfiniteQueryData(parameters: GetUomByIdParameters | ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetUomByIdData, GetUomByIdParameters>> | undefined, NoInfer<OperationInfiniteData<GetUomByIdData, GetUomByIdParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetUomByIdData, GetUomByIdParameters> | undefined;
        /** @summary Get a UOM by ID */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>, updater: Updater<NoInfer<GetUomByIdData> | undefined, NoInfer<GetUomByIdData> | undefined>, options?: SetDataOptions): Array<GetUomByIdData | undefined>;
        /** @summary Get a UOM by ID */
        setQueryData(parameters: (GetUomByIdParameters) | ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>, updater: Updater<NoInfer<GetUomByIdData> | undefined, NoInfer<GetUomByIdData> | undefined>, options?: SetDataOptions): GetUomByIdData | undefined;
        /** @summary Get a UOM by ID */
        getInfiniteQueryKey(parameters: GetUomByIdParameters): ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.measurementService.getUomById.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUomByIdParameters, TQueryFnData = GetUomByIdData, TData = OperationInfiniteData<TQueryFnData, GetUomByIdParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetUomByIdError, TData, ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<TData, GetUomByIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.measurementService.getUomById.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUomByIdParameters, TQueryFnData = GetUomByIdData, TData = OperationInfiniteData<TQueryFnData, GetUomByIdParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetUomByIdError, TData, ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUomByIdData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<TData, GetUomByIdError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getUomByIdTotal = qraft.measurementService.getUomById.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getUomByIdByParametersTotal = qraft.measurementService.getUomById.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError> | QueryFiltersByQueryKey<GetUomByIdSchema, GetUomByIdData, TInfinite, GetUomByIdParameters, GetUomByIdError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getUomByIdResults = qraft.measurementService.getUomById.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * getUomByIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getUomByIdCombinedResults = qraft.measurementService.getUomById.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * getUomByIdCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetUomByIdSchema, GetUomByIdParameters, GetUomByIdData, GetUomByIdError>>, TCombinedResult = Array<UseQueryResult<GetUomByIdData, GetUomByIdError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetUomByIdData, GetUomByIdError>>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get a UOM by ID */
        getQueryKey(parameters: GetUomByIdParameters): ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.getUomById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUomByIdData>(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options?: Omit<UndefinedInitialDataOptions<GetUomByIdData, GetUomByIdError, TData, ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>>, "queryKey">): UseQueryResult<TData, GetUomByIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a UOM by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.getUomById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUomByIdData>(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options: Omit<DefinedInitialDataOptions<GetUomByIdData, GetUomByIdError, TData, ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetUomByIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.measurementService.getUomById.useSuspenseInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetUomByIdParameters, TData = GetUomByIdData>(parameters: ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetUomByIdData, GetUomByIdError, OperationInfiniteData<TData, GetUomByIdParameters>, GetUomByIdData, ServiceOperationInfiniteQueryKey<GetUomByIdSchema, GetUomByIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUomByIdData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUomByIdParameters>, GetUomByIdError | Error>;
        /** @summary Get a UOM by ID */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUomByIdSchema, GetUomByIdParameters, GetUomByIdData, GetUomByIdError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetUomByIdData, GetUomByIdError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUomByIdData, GetUomByIdError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get a UOM by ID */
        useSuspenseQuery<TData = GetUomByIdData>(parameters: ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters> | (GetUomByIdParameters), options?: Omit<UseSuspenseQueryOptions<GetUomByIdData, GetUomByIdError, TData, ServiceOperationQueryKey<GetUomByIdSchema, GetUomByIdParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetUomByIdError | Error>;
        schema: GetUomByIdSchema;
        types: {
            parameters: GetUomByIdParameters;
            data: GetUomByIdData;
            error: GetUomByIdError;
        };
    };
    /** @summary List all UOMs with pagination */
    listUoms: {
        /** @summary List all UOMs with pagination */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>, options?: CancelOptions): Promise<void>;
        /** @summary List all UOMs with pagination */
        getQueryKey(parameters: ListUomsParameters | void): ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List all UOMs with pagination
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListUomsData>(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options?: Omit<UndefinedInitialDataOptions<ListUomsData, ListUomsError, TData, ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>>, "queryKey">): UseQueryResult<TData, ListUomsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List all UOMs with pagination
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListUomsData>(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options: Omit<DefinedInitialDataOptions<ListUomsData, ListUomsError, TData, ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>>, "queryKey">): DefinedUseQueryResult<TData, ListUomsError | Error>;
        /** @summary List all UOMs with pagination */
        fetchInfiniteQuery<TPageParam extends ListUomsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<ListUomsSchema, ListUomsData, ListUomsParameters, TPageParam, ListUomsError>): Promise<OperationInfiniteData<ListUomsData, ListUomsParameters>>;
        /** @summary List all UOMs with pagination */
        prefetchInfiniteQuery<TPageParam extends ListUomsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<ListUomsSchema, ListUomsData, ListUomsParameters, TPageParam, ListUomsError>): Promise<void>;
        /** @summary List all UOMs with pagination */
        ensureInfiniteQueryData<TPageParam extends ListUomsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<ListUomsSchema, ListUomsData, ListUomsParameters, TPageParam, ListUomsError>): Promise<OperationInfiniteData<ListUomsData, ListUomsParameters>>;
        /** @summary List all UOMs with pagination */
        fetchQuery(options: ServiceOperationFetchQueryOptions<ListUomsSchema, ListUomsData, ListUomsParameters, ListUomsError> | void): Promise<ListUomsData>;
        /** @summary List all UOMs with pagination */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<ListUomsSchema, ListUomsData, ListUomsParameters, ListUomsError> | void): Promise<void>;
        /** @summary List all UOMs with pagination */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<ListUomsSchema, ListUomsData, ListUomsParameters, ListUomsError> | void): Promise<ListUomsData>;
        /** @summary List all UOMs with pagination */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void)): OperationInfiniteData<ListUomsData, ListUomsParameters> | undefined;
        /** @summary List all UOMs with pagination */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters>,
            data: NoInfer<OperationInfiniteData<ListUomsData, ListUomsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>,
            data: ListUomsData | undefined
        ]>;
        /** @summary List all UOMs with pagination */
        getQueryData(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void)): ListUomsData | undefined;
        /** @summary List all UOMs with pagination */
        getQueryState(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void)): QueryState<ListUomsData, ListUomsError> | undefined;
        /** @summary List all UOMs with pagination */
        getInfiniteQueryState(parameters: ListUomsParameters | ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters> | void): QueryState<OperationInfiniteData<ListUomsData, ListUomsParameters>, ListUomsError> | undefined;
        /** @summary List all UOMs with pagination */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>, options?: InvalidateOptions): Promise<void>;
        /** @summary List all UOMs with pagination */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>): number;
        /** @summary List all UOMs with pagination */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<ListUomsSchema, ListUomsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<ListUomsParameters, TMeta, TSignal> | void), client?: (schema: ListUomsSchema, options: {
            parameters: ListUomsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<ListUomsData, ListUomsError>>): Promise<RequestFnResponse<ListUomsData, ListUomsError>>;
        /** @summary List all UOMs with pagination */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>, options?: RefetchOptions): Promise<void>;
        /** @summary List all UOMs with pagination */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>): void;
        /** @summary List all UOMs with pagination */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>, options?: ResetOptions): Promise<void>;
        /** @summary List all UOMs with pagination */
        setInfiniteQueryData(parameters: ListUomsParameters | ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters>, updater: Updater<NoInfer<OperationInfiniteData<ListUomsData, ListUomsParameters>> | undefined, NoInfer<OperationInfiniteData<ListUomsData, ListUomsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<ListUomsData, ListUomsParameters> | undefined;
        /** @summary List all UOMs with pagination */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>, updater: Updater<NoInfer<ListUomsData> | undefined, NoInfer<ListUomsData> | undefined>, options?: SetDataOptions): Array<ListUomsData | undefined>;
        /** @summary List all UOMs with pagination */
        setQueryData(parameters: (ListUomsParameters | undefined) | ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>, updater: Updater<NoInfer<ListUomsData> | undefined, NoInfer<ListUomsData> | undefined>, options?: SetDataOptions): ListUomsData | undefined;
        /** @summary List all UOMs with pagination */
        getInfiniteQueryKey(parameters: ListUomsParameters | void): ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.measurementService.listUoms.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends ListUomsParameters, TQueryFnData = ListUomsData, TData = OperationInfiniteData<TQueryFnData, ListUomsParameters>>(parameters: ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, ListUomsError, TData, ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<TData, ListUomsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.measurementService.listUoms.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends ListUomsParameters, TQueryFnData = ListUomsData, TData = OperationInfiniteData<TQueryFnData, ListUomsParameters>>(parameters: ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, ListUomsError, TData, ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<ListUomsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<TData, ListUomsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const listUomsTotal = qraft.measurementService.listUoms.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const listUomsByParametersTotal = qraft.measurementService.listUoms.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             page: page
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError> | QueryFiltersByQueryKey<ListUomsSchema, ListUomsData, TInfinite, ListUomsParameters, ListUomsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary List all UOMs with pagination
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const listUomsResults = qraft.measurementService.listUoms.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 page: page1
         *             }
         *         },
         *         {
         *             query: {
         *                 page: page2
         *             }
         *         }
         *     ]
         * });
         * listUomsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const listUomsCombinedResults = qraft.measurementService.listUoms.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 page: page1
         *             }
         *         },
         *         {
         *             query: {
         *                 page: page2
         *             }
         *         }
         *     ]
         * });
         * listUomsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<ListUomsSchema, ListUomsParameters, ListUomsData, ListUomsError>>, TCombinedResult = Array<UseQueryResult<ListUomsData, ListUomsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<ListUomsData, ListUomsError>>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary List all UOMs with pagination */
        getQueryKey(parameters: ListUomsParameters | void): ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List all UOMs with pagination
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListUomsData>(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options?: Omit<UndefinedInitialDataOptions<ListUomsData, ListUomsError, TData, ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>>, "queryKey">): UseQueryResult<TData, ListUomsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List all UOMs with pagination
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.measurementService.listUoms.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListUomsData>(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options: Omit<DefinedInitialDataOptions<ListUomsData, ListUomsError, TData, ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>>, "queryKey">): DefinedUseQueryResult<TData, ListUomsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.measurementService.listUoms.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends ListUomsParameters, TData = ListUomsData>(parameters: ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<ListUomsData, ListUomsError, OperationInfiniteData<TData, ListUomsParameters>, ListUomsData, ServiceOperationInfiniteQueryKey<ListUomsSchema, ListUomsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<ListUomsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, ListUomsParameters>, ListUomsError | Error>;
        /** @summary List all UOMs with pagination */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<ListUomsSchema, ListUomsParameters, ListUomsData, ListUomsError>>, TCombinedResult = Array<UseSuspenseQueryResult<ListUomsData, ListUomsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<ListUomsData, ListUomsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary List all UOMs with pagination */
        useSuspenseQuery<TData = ListUomsData>(parameters: ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters> | (ListUomsParameters | void), options?: Omit<UseSuspenseQueryOptions<ListUomsData, ListUomsError, TData, ServiceOperationQueryKey<ListUomsSchema, ListUomsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, ListUomsError | Error>;
        schema: ListUomsSchema;
        types: {
            parameters: ListUomsParameters;
            data: ListUomsData;
            error: ListUomsError;
        };
    };
}
export const measurementService: {
    /**
     * @summary Create a new UOM
     * @description Create a new UOM with the given name
     */
    createUom: {
        schema: {
            method: "post";
            url: "/uoms/create_uom";
            mediaType: [
                "application/json"
            ];
        };
    };
    /** @summary Delete a UOM by ID */
    deleteUom: {
        schema: {
            method: "delete";
            url: "/uoms/delete_uom/{id}";
        };
    };
    /** @summary Get a UOM by ID */
    getUomById: {
        schema: {
            method: "get";
            url: "/uoms/get_uom_by_id/{id}";
        };
    };
    /** @summary List all UOMs with pagination */
    listUoms: {
        schema: {
            method: "get";
            url: "/uoms/list_uoms";
        };
    };
} = {
    createUom: {
        schema: {
            method: "post",
            url: "/uoms/create_uom",
            mediaType: ["application/json"]
        }
    },
    deleteUom: {
        schema: {
            method: "delete",
            url: "/uoms/delete_uom/{id}"
        }
    },
    getUomById: {
        schema: {
            method: "get",
            url: "/uoms/get_uom_by_id/{id}"
        }
    },
    listUoms: {
        schema: {
            method: "get",
            url: "/uoms/list_uoms"
        }
    }
};
type CreateUomSchema = {
    method: "post";
    url: "/uoms/create_uom";
    mediaType: [
        "application/json"
    ];
};
type CreateUomParameters = {};
type CreateUomData = unknown;
type CreateUomError = unknown;
type CreateUomBody = NonNullable<paths["/uoms/create_uom"]["post"]["requestBody"]>["content"]["application/json"];
type DeleteUomSchema = {
    method: "delete";
    url: "/uoms/delete_uom/{id}";
};
type DeleteUomParameters = paths["/uoms/delete_uom/{id}"]["delete"]["parameters"];
type DeleteUomData = unknown;
type DeleteUomError = unknown;
type DeleteUomBody = undefined;
type GetUomByIdSchema = {
    method: "get";
    url: "/uoms/get_uom_by_id/{id}";
};
type GetUomByIdParameters = paths["/uoms/get_uom_by_id/{id}"]["get"]["parameters"];
type GetUomByIdData = paths["/uoms/get_uom_by_id/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUomByIdError = unknown;
type ListUomsSchema = {
    method: "get";
    url: "/uoms/list_uoms";
};
type ListUomsParameters = paths["/uoms/list_uoms"]["get"]["parameters"];
type ListUomsData = paths["/uoms/list_uoms"]["get"]["responses"]["200"]["content"]["application/json"];
type ListUomsError = unknown;

/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { AreAllOptional, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional } from "@openapi-qraft/tanstack-query-react-types";
import type { DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
import type { CancelOptions, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, Updater } from "@tanstack/query-core";
export interface CatalogService {
    /**
     * @summary Create a new category
     * @description Create a new category with the given name and optional parent category
     */
    createCategory: {
        /**
         * @summary Create a new category
         * @description Create a new category with the given name and optional parent category
         */
        getMutationKey(parameters: CreateCategoryParameters | void): ServiceOperationMutationKey<CreateCategorySchema, CreateCategoryParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.createCategory.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.createCategory.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends CreateCategoryBody, TContext = unknown>(parameters: CreateCategoryParameters, options?: ServiceOperationUseMutationOptions<CreateCategorySchema, CreateCategoryData, CreateCategoryParameters, TVariables, CreateCategoryError | Error, TContext>): UseMutationResult<CreateCategoryData, CreateCategoryError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.createCategory.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.createCategory.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<CreateCategoryBody, CreateCategoryParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<CreateCategorySchema, CreateCategoryData, CreateCategoryParameters, TVariables, CreateCategoryError | Error, TContext>): UseMutationResult<CreateCategoryData, CreateCategoryError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Create a new category
         * @description Create a new category with the given name and optional parent category
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const createCategoryTotal = qraft.catalogService.createCategory.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const createCategoryTotal = qraft.catalogService.createCategory.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<CreateCategoryBody, CreateCategoryData, CreateCategoryParameters, CreateCategoryError | Error, TContext> | MutationFiltersByMutationKey<CreateCategorySchema, CreateCategoryBody, CreateCategoryData, CreateCategoryParameters, CreateCategoryError | Error, TContext>): number;
        /**
         * @summary Create a new category
         * @description Create a new category with the given name and optional parent category
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<CreateCategoryBody, CreateCategoryData, CreateCategoryParameters, CreateCategoryError | Error, TContext> | MutationFiltersByMutationKey<CreateCategorySchema, CreateCategoryBody, CreateCategoryData, CreateCategoryParameters, CreateCategoryError | Error, TContext>): number;
        /**
         * @summary Create a new category
         * @description Create a new category with the given name and optional parent category
         */
        (options: ServiceOperationMutationFnOptions<CreateCategoryBody, CreateCategoryParameters>, client?: (schema: CreateCategorySchema, options: ServiceOperationMutationFnOptions<CreateCategoryBody, CreateCategoryParameters>) => Promise<RequestFnResponse<CreateCategoryData, CreateCategoryError>>): Promise<RequestFnResponse<CreateCategoryData, CreateCategoryError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Create a new category
         * @description Create a new category with the given name and optional parent category
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const createCategoryPendingMutationVariables = qraft.catalogService.createCategory.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const createCategoryMutationData = qraft.catalogService.createCategory.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<CreateCategoryData, CreateCategoryError | Error, MutationVariables<CreateCategoryBody, CreateCategoryParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<CreateCategoryBody, CreateCategoryData, CreateCategoryParameters, CreateCategoryError | Error, TContext> | MutationFiltersByMutationKey<CreateCategorySchema, CreateCategoryBody, CreateCategoryData, CreateCategoryParameters, CreateCategoryError | Error, TContext>;
            select?: (mutation: Mutation<CreateCategoryData, CreateCategoryError | Error, MutationVariables<CreateCategoryBody, CreateCategoryParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: CreateCategorySchema;
        types: {
            parameters: CreateCategoryParameters;
            data: CreateCategoryData;
            error: CreateCategoryError;
            body: CreateCategoryBody;
        };
    };
    /**
     * @summary Delete category by ID
     * @description Delete a category by its ID
     */
    deleteCategory: {
        /**
         * @summary Delete category by ID
         * @description Delete a category by its ID
         */
        getMutationKey(parameters: DeleteCategoryParameters | void): ServiceOperationMutationKey<DeleteCategorySchema, DeleteCategoryParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.deleteCategory.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.deleteCategory.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteCategoryBody, TContext = unknown>(parameters: DeleteCategoryParameters, options?: ServiceOperationUseMutationOptions<DeleteCategorySchema, DeleteCategoryData, DeleteCategoryParameters, TVariables, DeleteCategoryError | Error, TContext>): UseMutationResult<DeleteCategoryData, DeleteCategoryError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.deleteCategory.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.catalogService.deleteCategory.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteCategoryBody, DeleteCategoryParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteCategorySchema, DeleteCategoryData, DeleteCategoryParameters, TVariables, DeleteCategoryError | Error, TContext>): UseMutationResult<DeleteCategoryData, DeleteCategoryError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Delete category by ID
         * @description Delete a category by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteCategoryTotal = qraft.catalogService.deleteCategory.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteCategoryTotal = qraft.catalogService.deleteCategory.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteCategoryBody, DeleteCategoryData, DeleteCategoryParameters, DeleteCategoryError | Error, TContext> | MutationFiltersByMutationKey<DeleteCategorySchema, DeleteCategoryBody, DeleteCategoryData, DeleteCategoryParameters, DeleteCategoryError | Error, TContext>): number;
        /**
         * @summary Delete category by ID
         * @description Delete a category by its ID
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteCategoryBody, DeleteCategoryData, DeleteCategoryParameters, DeleteCategoryError | Error, TContext> | MutationFiltersByMutationKey<DeleteCategorySchema, DeleteCategoryBody, DeleteCategoryData, DeleteCategoryParameters, DeleteCategoryError | Error, TContext>): number;
        /**
         * @summary Delete category by ID
         * @description Delete a category by its ID
         */
        (options: ServiceOperationMutationFnOptions<DeleteCategoryBody, DeleteCategoryParameters>, client?: (schema: DeleteCategorySchema, options: ServiceOperationMutationFnOptions<DeleteCategoryBody, DeleteCategoryParameters>) => Promise<RequestFnResponse<DeleteCategoryData, DeleteCategoryError>>): Promise<RequestFnResponse<DeleteCategoryData, DeleteCategoryError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Delete category by ID
         * @description Delete a category by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteCategoryPendingMutationVariables = qraft.catalogService.deleteCategory.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteCategoryMutationData = qraft.catalogService.deleteCategory.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteCategoryData, DeleteCategoryError | Error, MutationVariables<DeleteCategoryBody, DeleteCategoryParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteCategoryBody, DeleteCategoryData, DeleteCategoryParameters, DeleteCategoryError | Error, TContext> | MutationFiltersByMutationKey<DeleteCategorySchema, DeleteCategoryBody, DeleteCategoryData, DeleteCategoryParameters, DeleteCategoryError | Error, TContext>;
            select?: (mutation: Mutation<DeleteCategoryData, DeleteCategoryError | Error, MutationVariables<DeleteCategoryBody, DeleteCategoryParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: DeleteCategorySchema;
        types: {
            parameters: DeleteCategoryParameters;
            data: DeleteCategoryData;
            error: DeleteCategoryError;
            body: DeleteCategoryBody;
        };
    };
    /** @summary Get a category by ID */
    getCategoryById: {
        /** @summary Get a category by ID */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>, options?: CancelOptions): Promise<void>;
        /** @summary Get a category by ID */
        getQueryKey(parameters: GetCategoryByIdParameters): ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a category by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.getCategoryById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCategoryByIdData>(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options?: Omit<UndefinedInitialDataOptions<GetCategoryByIdData, GetCategoryByIdError, TData, ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>>, "queryKey">): UseQueryResult<TData, GetCategoryByIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a category by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.getCategoryById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCategoryByIdData>(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options: Omit<DefinedInitialDataOptions<GetCategoryByIdData, GetCategoryByIdError, TData, ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCategoryByIdError | Error>;
        /** @summary Get a category by ID */
        fetchInfiniteQuery<TPageParam extends GetCategoryByIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCategoryByIdSchema, GetCategoryByIdData, GetCategoryByIdParameters, TPageParam, GetCategoryByIdError>): Promise<OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters>>;
        /** @summary Get a category by ID */
        prefetchInfiniteQuery<TPageParam extends GetCategoryByIdParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetCategoryByIdSchema, GetCategoryByIdData, GetCategoryByIdParameters, TPageParam, GetCategoryByIdError>): Promise<void>;
        /** @summary Get a category by ID */
        ensureInfiniteQueryData<TPageParam extends GetCategoryByIdParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetCategoryByIdSchema, GetCategoryByIdData, GetCategoryByIdParameters, TPageParam, GetCategoryByIdError>): Promise<OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters>>;
        /** @summary Get a category by ID */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetCategoryByIdSchema, GetCategoryByIdData, GetCategoryByIdParameters, GetCategoryByIdError>): Promise<GetCategoryByIdData>;
        /** @summary Get a category by ID */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetCategoryByIdSchema, GetCategoryByIdData, GetCategoryByIdParameters, GetCategoryByIdError>): Promise<void>;
        /** @summary Get a category by ID */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetCategoryByIdSchema, GetCategoryByIdData, GetCategoryByIdParameters, GetCategoryByIdError>): Promise<GetCategoryByIdData>;
        /** @summary Get a category by ID */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters)): OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters> | undefined;
        /** @summary Get a category by ID */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>,
            data: NoInfer<OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>,
            data: GetCategoryByIdData | undefined
        ]>;
        /** @summary Get a category by ID */
        getQueryData(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters)): GetCategoryByIdData | undefined;
        /** @summary Get a category by ID */
        getQueryState(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters)): QueryState<GetCategoryByIdData, GetCategoryByIdError> | undefined;
        /** @summary Get a category by ID */
        getInfiniteQueryState(parameters: GetCategoryByIdParameters | ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>): QueryState<OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters>, GetCategoryByIdError> | undefined;
        /** @summary Get a category by ID */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get a category by ID */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>): number;
        /** @summary Get a category by ID */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetCategoryByIdParameters, TMeta, TSignal>), client?: (schema: GetCategoryByIdSchema, options: {
            parameters: GetCategoryByIdParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetCategoryByIdData, GetCategoryByIdError>>): Promise<RequestFnResponse<GetCategoryByIdData, GetCategoryByIdError>>;
        /** @summary Get a category by ID */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get a category by ID */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>): void;
        /** @summary Get a category by ID */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>, options?: ResetOptions): Promise<void>;
        /** @summary Get a category by ID */
        setInfiniteQueryData(parameters: GetCategoryByIdParameters | ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters>> | undefined, NoInfer<OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetCategoryByIdData, GetCategoryByIdParameters> | undefined;
        /** @summary Get a category by ID */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>, updater: Updater<NoInfer<GetCategoryByIdData> | undefined, NoInfer<GetCategoryByIdData> | undefined>, options?: SetDataOptions): Array<GetCategoryByIdData | undefined>;
        /** @summary Get a category by ID */
        setQueryData(parameters: (GetCategoryByIdParameters) | ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>, updater: Updater<NoInfer<GetCategoryByIdData> | undefined, NoInfer<GetCategoryByIdData> | undefined>, options?: SetDataOptions): GetCategoryByIdData | undefined;
        /** @summary Get a category by ID */
        getInfiniteQueryKey(parameters: GetCategoryByIdParameters): ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.catalogService.getCategoryById.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCategoryByIdParameters, TQueryFnData = GetCategoryByIdData, TData = OperationInfiniteData<TQueryFnData, GetCategoryByIdParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetCategoryByIdError, TData, ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<TData, GetCategoryByIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.catalogService.getCategoryById.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetCategoryByIdParameters, TQueryFnData = GetCategoryByIdData, TData = OperationInfiniteData<TQueryFnData, GetCategoryByIdParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetCategoryByIdError, TData, ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCategoryByIdData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<TData, GetCategoryByIdError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getCategoryByIdTotal = qraft.catalogService.getCategoryById.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getCategoryByIdByParametersTotal = qraft.catalogService.getCategoryById.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError> | QueryFiltersByQueryKey<GetCategoryByIdSchema, GetCategoryByIdData, TInfinite, GetCategoryByIdParameters, GetCategoryByIdError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get a category by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getCategoryByIdResults = qraft.catalogService.getCategoryById.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * getCategoryByIdResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getCategoryByIdCombinedResults = qraft.catalogService.getCategoryById.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * getCategoryByIdCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetCategoryByIdSchema, GetCategoryByIdParameters, GetCategoryByIdData, GetCategoryByIdError>>, TCombinedResult = Array<UseQueryResult<GetCategoryByIdData, GetCategoryByIdError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetCategoryByIdData, GetCategoryByIdError>>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get a category by ID */
        getQueryKey(parameters: GetCategoryByIdParameters): ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a category by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.getCategoryById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCategoryByIdData>(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options?: Omit<UndefinedInitialDataOptions<GetCategoryByIdData, GetCategoryByIdError, TData, ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>>, "queryKey">): UseQueryResult<TData, GetCategoryByIdError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get a category by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.getCategoryById.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = GetCategoryByIdData>(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options: Omit<DefinedInitialDataOptions<GetCategoryByIdData, GetCategoryByIdError, TData, ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>>, "queryKey">): DefinedUseQueryResult<TData, GetCategoryByIdError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.catalogService.getCategoryById.useSuspenseInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetCategoryByIdParameters, TData = GetCategoryByIdData>(parameters: ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options: Omit<UseSuspenseInfiniteQueryOptions<GetCategoryByIdData, GetCategoryByIdError, OperationInfiniteData<TData, GetCategoryByIdParameters>, GetCategoryByIdData, ServiceOperationInfiniteQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetCategoryByIdData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetCategoryByIdParameters>, GetCategoryByIdError | Error>;
        /** @summary Get a category by ID */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetCategoryByIdSchema, GetCategoryByIdParameters, GetCategoryByIdData, GetCategoryByIdError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetCategoryByIdData, GetCategoryByIdError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetCategoryByIdData, GetCategoryByIdError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get a category by ID */
        useSuspenseQuery<TData = GetCategoryByIdData>(parameters: ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters> | (GetCategoryByIdParameters), options?: Omit<UseSuspenseQueryOptions<GetCategoryByIdData, GetCategoryByIdError, TData, ServiceOperationQueryKey<GetCategoryByIdSchema, GetCategoryByIdParameters>>, "queryKey">): UseSuspenseQueryResult<TData, GetCategoryByIdError | Error>;
        schema: GetCategoryByIdSchema;
        types: {
            parameters: GetCategoryByIdParameters;
            data: GetCategoryByIdData;
            error: GetCategoryByIdError;
        };
    };
    /**
     * @summary Get all categories with pagination
     * @description Get a paginated list of all categories
     */
    listCategories: {
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getQueryKey(parameters: ListCategoriesParameters | void): ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListCategoriesData>(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options?: Omit<UndefinedInitialDataOptions<ListCategoriesData, ListCategoriesError, TData, ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>>, "queryKey">): UseQueryResult<TData, ListCategoriesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListCategoriesData>(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options: Omit<DefinedInitialDataOptions<ListCategoriesData, ListCategoriesError, TData, ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>>, "queryKey">): DefinedUseQueryResult<TData, ListCategoriesError | Error>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        fetchInfiniteQuery<TPageParam extends ListCategoriesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<ListCategoriesSchema, ListCategoriesData, ListCategoriesParameters, TPageParam, ListCategoriesError>): Promise<OperationInfiniteData<ListCategoriesData, ListCategoriesParameters>>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        prefetchInfiniteQuery<TPageParam extends ListCategoriesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<ListCategoriesSchema, ListCategoriesData, ListCategoriesParameters, TPageParam, ListCategoriesError>): Promise<void>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        ensureInfiniteQueryData<TPageParam extends ListCategoriesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<ListCategoriesSchema, ListCategoriesData, ListCategoriesParameters, TPageParam, ListCategoriesError>): Promise<OperationInfiniteData<ListCategoriesData, ListCategoriesParameters>>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<ListCategoriesSchema, ListCategoriesData, ListCategoriesParameters, ListCategoriesError> | void): Promise<ListCategoriesData>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<ListCategoriesSchema, ListCategoriesData, ListCategoriesParameters, ListCategoriesError> | void): Promise<void>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<ListCategoriesSchema, ListCategoriesData, ListCategoriesParameters, ListCategoriesError> | void): Promise<ListCategoriesData>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void)): OperationInfiniteData<ListCategoriesData, ListCategoriesParameters> | undefined;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters>,
            data: NoInfer<OperationInfiniteData<ListCategoriesData, ListCategoriesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>,
            data: ListCategoriesData | undefined
        ]>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getQueryData(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void)): ListCategoriesData | undefined;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getQueryState(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void)): QueryState<ListCategoriesData, ListCategoriesError> | undefined;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getInfiniteQueryState(parameters: ListCategoriesParameters | ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters> | void): QueryState<OperationInfiniteData<ListCategoriesData, ListCategoriesParameters>, ListCategoriesError> | undefined;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>): number;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<ListCategoriesSchema, ListCategoriesParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<ListCategoriesParameters, TMeta, TSignal> | void), client?: (schema: ListCategoriesSchema, options: {
            parameters: ListCategoriesParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<ListCategoriesData, ListCategoriesError>>): Promise<RequestFnResponse<ListCategoriesData, ListCategoriesError>>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>): void;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        setInfiniteQueryData(parameters: ListCategoriesParameters | ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters>, updater: Updater<NoInfer<OperationInfiniteData<ListCategoriesData, ListCategoriesParameters>> | undefined, NoInfer<OperationInfiniteData<ListCategoriesData, ListCategoriesParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<ListCategoriesData, ListCategoriesParameters> | undefined;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>, updater: Updater<NoInfer<ListCategoriesData> | undefined, NoInfer<ListCategoriesData> | undefined>, options?: SetDataOptions): Array<ListCategoriesData | undefined>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        setQueryData(parameters: (ListCategoriesParameters | undefined) | ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>, updater: Updater<NoInfer<ListCategoriesData> | undefined, NoInfer<ListCategoriesData> | undefined>, options?: SetDataOptions): ListCategoriesData | undefined;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getInfiniteQueryKey(parameters: ListCategoriesParameters | void): ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.catalogService.listCategories.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends ListCategoriesParameters, TQueryFnData = ListCategoriesData, TData = OperationInfiniteData<TQueryFnData, ListCategoriesParameters>>(parameters: ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, ListCategoriesError, TData, ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<TData, ListCategoriesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.catalogService.listCategories.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends ListCategoriesParameters, TQueryFnData = ListCategoriesData, TData = OperationInfiniteData<TQueryFnData, ListCategoriesParameters>>(parameters: ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, ListCategoriesError, TData, ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<ListCategoriesData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<TData, ListCategoriesError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const listCategoriesTotal = qraft.catalogService.listCategories.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const listCategoriesByParametersTotal = qraft.catalogService.listCategories.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             page: page
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError> | QueryFiltersByQueryKey<ListCategoriesSchema, ListCategoriesData, TInfinite, ListCategoriesParameters, ListCategoriesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const listCategoriesResults = qraft.catalogService.listCategories.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 page: page1
         *             }
         *         },
         *         {
         *             query: {
         *                 page: page2
         *             }
         *         }
         *     ]
         * });
         * listCategoriesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const listCategoriesCombinedResults = qraft.catalogService.listCategories.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 page: page1
         *             }
         *         },
         *         {
         *             query: {
         *                 page: page2
         *             }
         *         }
         *     ]
         * });
         * listCategoriesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<ListCategoriesSchema, ListCategoriesParameters, ListCategoriesData, ListCategoriesError>>, TCombinedResult = Array<UseQueryResult<ListCategoriesData, ListCategoriesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<ListCategoriesData, ListCategoriesError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        getQueryKey(parameters: ListCategoriesParameters | void): ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListCategoriesData>(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options?: Omit<UndefinedInitialDataOptions<ListCategoriesData, ListCategoriesError, TData, ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>>, "queryKey">): UseQueryResult<TData, ListCategoriesError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.catalogService.listCategories.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = ListCategoriesData>(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options: Omit<DefinedInitialDataOptions<ListCategoriesData, ListCategoriesError, TData, ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>>, "queryKey">): DefinedUseQueryResult<TData, ListCategoriesError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.catalogService.listCategories.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends ListCategoriesParameters, TData = ListCategoriesData>(parameters: ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<ListCategoriesData, ListCategoriesError, OperationInfiniteData<TData, ListCategoriesParameters>, ListCategoriesData, ServiceOperationInfiniteQueryKey<ListCategoriesSchema, ListCategoriesParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<ListCategoriesData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, ListCategoriesParameters>, ListCategoriesError | Error>;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<ListCategoriesSchema, ListCategoriesParameters, ListCategoriesData, ListCategoriesError>>, TCombinedResult = Array<UseSuspenseQueryResult<ListCategoriesData, ListCategoriesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<ListCategoriesData, ListCategoriesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get all categories with pagination
         * @description Get a paginated list of all categories
         */
        useSuspenseQuery<TData = ListCategoriesData>(parameters: ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters> | (ListCategoriesParameters | void), options?: Omit<UseSuspenseQueryOptions<ListCategoriesData, ListCategoriesError, TData, ServiceOperationQueryKey<ListCategoriesSchema, ListCategoriesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, ListCategoriesError | Error>;
        schema: ListCategoriesSchema;
        types: {
            parameters: ListCategoriesParameters;
            data: ListCategoriesData;
            error: ListCategoriesError;
        };
    };
}
export const catalogService: {
    /**
     * @summary Create a new category
     * @description Create a new category with the given name and optional parent category
     */
    createCategory: {
        schema: {
            method: "post";
            url: "/categories/create_category";
            mediaType: [
                "application/json"
            ];
        };
    };
    /**
     * @summary Delete category by ID
     * @description Delete a category by its ID
     */
    deleteCategory: {
        schema: {
            method: "post";
            url: "/categories/delete_category/{id}";
        };
    };
    /** @summary Get a category by ID */
    getCategoryById: {
        schema: {
            method: "get";
            url: "/categories/get_category_by_id/{id}";
        };
    };
    /**
     * @summary Get all categories with pagination
     * @description Get a paginated list of all categories
     */
    listCategories: {
        schema: {
            method: "get";
            url: "/categories/list_categories";
        };
    };
} = {
    createCategory: {
        schema: {
            method: "post",
            url: "/categories/create_category",
            mediaType: ["application/json"]
        }
    },
    deleteCategory: {
        schema: {
            method: "post",
            url: "/categories/delete_category/{id}"
        }
    },
    getCategoryById: {
        schema: {
            method: "get",
            url: "/categories/get_category_by_id/{id}"
        }
    },
    listCategories: {
        schema: {
            method: "get",
            url: "/categories/list_categories"
        }
    }
};
type CreateCategorySchema = {
    method: "post";
    url: "/categories/create_category";
    mediaType: [
        "application/json"
    ];
};
type CreateCategoryParameters = {};
type CreateCategoryData = unknown;
type CreateCategoryError = unknown;
type CreateCategoryBody = NonNullable<paths["/categories/create_category"]["post"]["requestBody"]>["content"]["application/json"];
type DeleteCategorySchema = {
    method: "post";
    url: "/categories/delete_category/{id}";
};
type DeleteCategoryParameters = paths["/categories/delete_category/{id}"]["post"]["parameters"];
type DeleteCategoryData = unknown;
type DeleteCategoryError = unknown;
type DeleteCategoryBody = undefined;
type GetCategoryByIdSchema = {
    method: "get";
    url: "/categories/get_category_by_id/{id}";
};
type GetCategoryByIdParameters = paths["/categories/get_category_by_id/{id}"]["get"]["parameters"];
type GetCategoryByIdData = paths["/categories/get_category_by_id/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetCategoryByIdError = unknown;
type ListCategoriesSchema = {
    method: "get";
    url: "/categories/list_categories";
};
type ListCategoriesParameters = paths["/categories/list_categories"]["get"]["parameters"];
type ListCategoriesData = paths["/categories/list_categories"]["get"]["responses"]["200"]["content"]["application/json"];
type ListCategoriesError = unknown;
